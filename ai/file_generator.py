"""Stage 4 — Generate all config files in one call.

Uses the AI provider abstraction (Claude Sonnet or Gemini Pro).
This is the only stage that uses the expensive model — accuracy is critical.
"""

from __future__ import annotations

import json
from dataclasses import dataclass, field
from typing import Any

from rich.console import Console

from ai.provider import call_ai
from core.constants import PROVIDER_CLAUDE
from core.spec_builder import ProjectSpec

console = Console()

# ---------------------------------------------------------------------------
# System prompt
# ---------------------------------------------------------------------------
SYSTEM_PROMPT = (
    "You are an expert in Claude Code and Gemini CLI optimization. "
    "Generate compressed, token-efficient configuration files. "
    "Use shorthand AI understands. No verbose prose. No explanations. "
    "Every file must be as small as possible while being complete. "
    "Respond ONLY with valid JSON. No markdown fences."
)

# ---------------------------------------------------------------------------
# Output schema
# ---------------------------------------------------------------------------
OUTPUT_SCHEMA = """{
  "claude": {
    "CLAUDE_md": "compressed content string",
    "settings_json": {},
    "rules": {
      "code_style": "string or null",
      "frontend": "string or null",
      "backend": "string or null",
      "database": "string or null",
      "testing": "string or null"
    },
    "agents_md": "string",
    "skills_md": "string",
    "hooks_json": null,
    "mcp_json": null
  },
  "gemini": {
    "GEMINI_md": "compressed content string",
    "settings_json": {}
  },
  "project": {
    "PLAN_md": "compressed build phases",
    "schema_json": {},
    "routes_json": [],
    "phases_json": []
  }
}"""


@dataclass
class GeneratedFiles:
    """Container for all files generated by Stage 4."""

    claude: dict[str, Any] = field(default_factory=dict)
    gemini: dict[str, Any] = field(default_factory=dict)
    project: dict[str, Any] = field(default_factory=dict)

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> GeneratedFiles:
        """Create a GeneratedFiles from a JSON-decoded dict."""
        return cls(
            claude=data.get("claude", {}),
            gemini=data.get("gemini", {}),
            project=data.get("project", {}),
        )


def generate_files(
    spec: ProjectSpec,
    *,
    provider: str = PROVIDER_CLAUDE,
    client: Any = None,
) -> GeneratedFiles:
    """Generate all configuration files from the complete project spec.

    One call generates everything — SPEC Rule 2.

    Args:
        spec: Complete project specification from all previous stages.
        provider: AI provider to use (``"claude"`` or ``"gemini"``).
        client: Optional pre-configured SDK client.

    Returns:
        A :class:`GeneratedFiles` container with all content.

    Raises:
        ValueError: If the AI response is not valid JSON after retry.
    """
    spec_json = json.dumps(spec.to_dict(), indent=2)
    user_message = (
        f"Complete project specification:\n{spec_json}\n\n"
        f"Generate ALL config files in one response.\n"
        f"Respond ONLY with JSON matching this schema:\n{OUTPUT_SCHEMA}"
    )

    data = call_ai(
        stage="generate",
        system_prompt=SYSTEM_PROMPT,
        user_message=user_message,
        provider=provider,
        client=client,
    )
    if data is not None:
        return GeneratedFiles.from_dict(data)

    # Retry once
    console.print("[yellow]⚠ JSON parse failed, retrying...[/yellow]")
    user_message_retry = (
        f"Complete project specification:\n{spec_json}\n\n"
        "CRITICAL: Your response MUST be valid JSON only. "
        "No markdown fences, no explanation, no text before or after.\n\n"
        f"Generate ALL config files matching this schema:\n{OUTPUT_SCHEMA}"
    )
    data = call_ai(
        stage="generate",
        system_prompt=SYSTEM_PROMPT,
        user_message=user_message_retry,
        provider=provider,
        client=client,
    )
    if data is not None:
        return GeneratedFiles.from_dict(data)

    raise ValueError("Failed to parse file generator response as JSON after retry.")
