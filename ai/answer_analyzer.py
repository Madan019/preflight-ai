"""Stage 3 — Analyze all answers, detect gaps and contradictions.

Uses the AI provider abstraction (Claude Haiku or Gemini Flash).
"""

from __future__ import annotations

import json
from typing import Any

from rich.console import Console

from ai.provider import call_ai
from core.constants import PROVIDER_CLAUDE
from core.spec_builder import AnalysisResult, QuestionSet

console = Console()

# ---------------------------------------------------------------------------
# System prompt
# ---------------------------------------------------------------------------
SYSTEM_PROMPT = (
    "You are a software architect reviewing project requirements. "
    "Detect gaps, contradictions, implicit needs. "
    "Auto-resolve obvious gaps. Flag real contradictions. "
    "Respond ONLY with valid JSON. No explanation."
)

# ---------------------------------------------------------------------------
# Output schema
# ---------------------------------------------------------------------------
OUTPUT_SCHEMA = """{
  "complete_spec": {
    "app_type": "string",
    "features": [],
    "stack": {},
    "auth": {},
    "database": {},
    "integrations": [],
    "deployment": {}
  },
  "gaps_auto_filled": [
    {
      "gap": "No error monitoring mentioned",
      "filled_with": "sentry",
      "reason": "Production app of this complexity needs error tracking"
    }
  ],
  "contradictions_resolved": [
    {
      "issue": "Said no auth but mentioned user profiles",
      "resolution": "Added JWT auth — required for user profiles to exist"
    }
  ],
  "implicit_requirements_added": [
    "rate_limiting (payments feature)",
    "email_service (auth feature requires password reset)"
  ],
  "recommended_rules": ["code-style", "frontend", "backend", "database", "testing"],
  "recommended_agents": ["test-runner", "code-reviewer", "migration-runner"],
  "recommended_skills": ["run-tests", "deploy", "db-migrate"],
  "confidence_score": 0.95
}"""


def analyze_answers(
    question_set: QuestionSet,
    answers: dict[str, str],
    parsed_idea_json: str,
    *,
    provider: str = PROVIDER_CLAUDE,
    client: Any = None,
) -> AnalysisResult:
    """Analyze user answers to detect gaps, contradictions, and implicit needs.

    Args:
        question_set: The questions generated by Stage 2.
        answers: Mapping of question id → user answer text.
        parsed_idea_json: JSON string of the Stage 1 parsed idea.
        provider: AI provider to use (``"claude"`` or ``"gemini"``).
        client: Optional pre-configured SDK client.

    Returns:
        An :class:`AnalysisResult` with the complete spec and gap analysis.

    Raises:
        ValueError: If the AI response is not valid JSON after retry.
    """
    # Build Q&A pairs
    qa_pairs = []
    for q in question_set.questions:
        answer = answers.get(q.id, q.default or "not answered")
        qa_pairs.append(
            {
                "id": q.id,
                "question": q.question,
                "answer": answer,
                "impacts": q.impacts,
            }
        )

    user_message = (
        f"Original parsed idea:\n{parsed_idea_json}\n\n"
        f"Questions and answers:\n{json.dumps(qa_pairs, indent=2)}\n\n"
        f"Respond ONLY with JSON matching this schema:\n{OUTPUT_SCHEMA}"
    )

    data = call_ai(
        stage="analysis",
        system_prompt=SYSTEM_PROMPT,
        user_message=user_message,
        provider=provider,
        client=client,
    )
    if data is not None:
        return AnalysisResult.from_dict(data)

    # Retry once
    console.print("[yellow]⚠ JSON parse failed, retrying...[/yellow]")
    user_message_retry = (
        f"Original parsed idea:\n{parsed_idea_json}\n\n"
        f"Questions and answers:\n{json.dumps(qa_pairs, indent=2)}\n\n"
        "CRITICAL: Your response MUST be valid JSON only. "
        "No markdown fences, no explanation.\n\n"
        f"Schema:\n{OUTPUT_SCHEMA}"
    )
    data = call_ai(
        stage="analysis",
        system_prompt=SYSTEM_PROMPT,
        user_message=user_message_retry,
        provider=provider,
        client=client,
    )
    if data is not None:
        return AnalysisResult.from_dict(data)

    raise ValueError("Failed to parse analysis response as JSON after retry.")
