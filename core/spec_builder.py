"""ProjectSpec dataclass â€” assembled from parsed idea + user answers + analysis."""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any


@dataclass
class StackSpec:
    """Technology stack chosen for the project."""

    language: str = ""
    frontend: str | None = None
    backend: str | None = None
    database: str | None = None
    auth: str | None = None
    hosting: str | None = None


@dataclass
class ParsedIdea:
    """Stage 1 output: structured requirements from plain-english idea."""

    app_type: str = ""
    core_purpose: str = ""
    features: list[str] = field(default_factory=list)
    integrations: list[str] = field(default_factory=list)
    complexity: str = "moderate"
    target_users: str = ""
    suggested_stack: dict[str, str] = field(default_factory=dict)
    similar_to: str = "none"
    implicit_requirements: list[str] = field(default_factory=list)
    ai_target: str = "both"

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> ParsedIdea:
        """Create a ParsedIdea from a JSON-decoded dict."""
        return cls(
            app_type=data.get("app_type", ""),
            core_purpose=data.get("core_purpose", ""),
            features=data.get("features", []),
            integrations=data.get("integrations", []),
            complexity=data.get("complexity", "moderate"),
            target_users=data.get("target_users", ""),
            suggested_stack=data.get("suggested_stack", {}),
            similar_to=data.get("similar_to", "none"),
            implicit_requirements=data.get("implicit_requirements", []),
            ai_target=data.get("ai_target", "both"),
        )


@dataclass
class Question:
    """A single follow-up question generated by Stage 2."""

    id: str
    question: str
    why_asking: str
    impacts: list[str] = field(default_factory=list)
    type: str = "choice"
    options: list[str] = field(default_factory=list)
    default: str = ""
    required: bool = True


@dataclass
class QuestionSet:
    """Stage 2 output: tailored follow-up questions."""

    questions: list[Question] = field(default_factory=list)
    total_questions: int = 0
    estimated_minutes: int = 3

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> QuestionSet:
        """Create a QuestionSet from a JSON-decoded dict."""
        questions = [
            Question(
                id=q.get("id", f"q{i+1}"),
                question=q.get("question", ""),
                why_asking=q.get("why_asking", ""),
                impacts=q.get("impacts", []),
                type=q.get("type", "choice"),
                options=q.get("options", []),
                default=q.get("default", ""),
                required=q.get("required", True),
            )
            for i, q in enumerate(data.get("questions", []))
        ]
        return cls(
            questions=questions,
            total_questions=data.get("total_questions", len(questions)),
            estimated_minutes=data.get("estimated_minutes", 3),
        )


@dataclass
class GapFill:
    """An auto-filled gap detected during analysis."""

    gap: str
    filled_with: str
    reason: str


@dataclass
class ContradictionResolution:
    """A contradiction detected and resolved during analysis."""

    issue: str
    resolution: str


@dataclass
class AnalysisResult:
    """Stage 3 output: complete spec with gaps filled and contradictions resolved."""

    complete_spec: dict[str, Any] = field(default_factory=dict)
    gaps_auto_filled: list[GapFill] = field(default_factory=list)
    contradictions_resolved: list[ContradictionResolution] = field(
        default_factory=list
    )
    implicit_requirements_added: list[str] = field(default_factory=list)
    recommended_rules: list[str] = field(default_factory=list)
    recommended_agents: list[str] = field(default_factory=list)
    recommended_skills: list[str] = field(default_factory=list)
    confidence_score: float = 0.0

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> AnalysisResult:
        """Create an AnalysisResult from a JSON-decoded dict."""
        gaps = [
            GapFill(
                gap=g.get("gap", ""),
                filled_with=g.get("filled_with", ""),
                reason=g.get("reason", ""),
            )
            for g in data.get("gaps_auto_filled", [])
        ]
        contradictions = [
            ContradictionResolution(
                issue=c.get("issue", ""),
                resolution=c.get("resolution", ""),
            )
            for c in data.get("contradictions_resolved", [])
        ]
        return cls(
            complete_spec=data.get("complete_spec", {}),
            gaps_auto_filled=gaps,
            contradictions_resolved=contradictions,
            implicit_requirements_added=data.get("implicit_requirements_added", []),
            recommended_rules=data.get("recommended_rules", []),
            recommended_agents=data.get("recommended_agents", []),
            recommended_skills=data.get("recommended_skills", []),
            confidence_score=data.get("confidence_score", 0.0),
        )


@dataclass
class ProjectSpec:
    """Complete project specification assembled from all stages."""

    # From Stage 1
    app_type: str = ""
    core_purpose: str = ""
    features: list[str] = field(default_factory=list)
    integrations: list[str] = field(default_factory=list)
    complexity: str = "moderate"
    target_users: str = ""
    similar_to: str = "none"
    ai_target: str = "both"

    # Stack
    stack: StackSpec = field(default_factory=StackSpec)

    # From Stage 2+3 answers
    user_answers: dict[str, str] = field(default_factory=dict)

    # From Stage 3 analysis
    implicit_requirements: list[str] = field(default_factory=list)
    gaps_auto_filled: list[GapFill] = field(default_factory=list)
    contradictions_resolved: list[ContradictionResolution] = field(
        default_factory=list
    )
    recommended_rules: list[str] = field(default_factory=list)
    recommended_agents: list[str] = field(default_factory=list)
    recommended_skills: list[str] = field(default_factory=list)
    confidence_score: float = 0.0

    # Deployment
    deployment: dict[str, Any] = field(default_factory=dict)

    @classmethod
    def from_stages(
        cls,
        parsed: ParsedIdea,
        answers: dict[str, str],
        analysis: AnalysisResult,
    ) -> ProjectSpec:
        """Assemble a ProjectSpec from all three stage outputs."""
        stack_data = analysis.complete_spec.get("stack", parsed.suggested_stack)
        stack = StackSpec(
            language=stack_data.get("language", ""),
            frontend=stack_data.get("frontend"),
            backend=stack_data.get("backend"),
            database=stack_data.get("database"),
            auth=stack_data.get("auth") or analysis.complete_spec.get("auth", {}).get("method"),
            hosting=stack_data.get("hosting"),
        )

        return cls(
            app_type=analysis.complete_spec.get("app_type", parsed.app_type),
            core_purpose=parsed.core_purpose,
            features=analysis.complete_spec.get("features", parsed.features),
            integrations=analysis.complete_spec.get("integrations", parsed.integrations),
            complexity=parsed.complexity,
            target_users=parsed.target_users,
            similar_to=parsed.similar_to,
            ai_target=parsed.ai_target,
            stack=stack,
            user_answers=answers,
            implicit_requirements=analysis.implicit_requirements_added,
            gaps_auto_filled=analysis.gaps_auto_filled,
            contradictions_resolved=analysis.contradictions_resolved,
            recommended_rules=analysis.recommended_rules,
            recommended_agents=analysis.recommended_agents,
            recommended_skills=analysis.recommended_skills,
            confidence_score=analysis.confidence_score,
            deployment=analysis.complete_spec.get("deployment", {}),
        )

    def to_dict(self) -> dict[str, Any]:
        """Serialize to a plain dict for JSON / AI prompt injection."""
        return {
            "app_type": self.app_type,
            "core_purpose": self.core_purpose,
            "features": self.features,
            "integrations": self.integrations,
            "complexity": self.complexity,
            "target_users": self.target_users,
            "similar_to": self.similar_to,
            "ai_target": self.ai_target,
            "stack": {
                "language": self.stack.language,
                "frontend": self.stack.frontend,
                "backend": self.stack.backend,
                "database": self.stack.database,
                "auth": self.stack.auth,
                "hosting": self.stack.hosting,
            },
            "user_answers": self.user_answers,
            "implicit_requirements": self.implicit_requirements,
            "recommended_rules": self.recommended_rules,
            "recommended_agents": self.recommended_agents,
            "recommended_skills": self.recommended_skills,
            "confidence_score": self.confidence_score,
            "deployment": self.deployment,
        }
